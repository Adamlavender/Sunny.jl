struct SFData{NumCorr} 
    data        :: Array{ComplexF64, 7}                  # Raw SF data for 1st BZ (numcorrelations x nbasis x nbasis x latsize x energy)
    crystal     :: Crystal
    Œîœâ          :: Float64                               # Energy step size
    idxinfo     :: SortedDict{CartesianIndex{2}, Int64}  # (Œ±, Œ≤) to save from ùíÆ^{Œ±Œ≤}(q, œâ)
end

struct SFTrajectory{N}
    sys          :: System{N}             # Clone system so original System unaltered by trajectory calculation
    traj         :: Array{ComplexF64, 6}  # Trajectory buffer
    ops          :: Array{ComplexF64, 3}  # Operators corresponding to observables
    measperiod   :: Int                   # Steps to skip between saving observables (downsampling)
    apply_g      :: Bool                  # Whether to apply the g-factor to recorded trajectories
    dipolemode   :: Bool                  # Whether considering only dipoles
    integrator   :: ImplicitMidpoint      # Integrator for dissipationless trajectories
    processtraj! :: Function              # Arbitrary function to process trajectory before FFT
end

mutable struct StructureFactor{N, NumCorr}
    sfdata      :: SFData{NumCorr}
    sftraj      :: SFTrajectory{N}
    nsamples    :: Int64
end

"""
    StructureFactor(sys::System; Œît = 0.1, nœâ = 1, œâmax = nothing,
                        apply_g = true, ops = nothing, matrix_elems = nothing)

`StructureFactor` is the basic type for calculating ``ùíÆ^{Œ±Œ≤}(q,œâ)``, storing
the results, and retrieving intensity information. 

Most users should use [`calculate_structure_factor`](@ref) to generate a
structure factor. However, one may also directly create a structure factor by
providing a `System` to `StructureFactor`. Then, to manually generate a sample,
the user must ensure that the spins of their system are drawn from an
appropriate equilibrium distribution and call [`add_trajectory!`](@ref)
function. This process may be repeated as necessary to generate a sufficient
statistics. 

The keywords specify all the parameters used in subsequent calculations and must
be determined at the time that the `StructureFactor` is initiated. Specifically:
- `Œît`: Sets the step size of the integrator used to calculate trajectories.
- `œâmax`: Determines the maximum resolved energy.
- `nœâ`: Determines how many energy bins to resolve between 0 and `œâmax`. If set
    to 1, Sunny will calculate a static structure factor.
- `apply_g`: Determines whether to apply the g-factor when calculating
    trajectories.
- `ops`: Enables an advanced feature for SU(_N_) mode, allowing the user to
    specify custom observables other than the three components of the dipole. To
    use this features, `ops` must be given an `N√óN√ónumops` array, where the
    final index is used to retrieve each `N√óN` operator.
- `matrix_elems`: Allows the user to specify which correlation functions are
    calculated. This is specified with a vector of tuples. By default Sunny
    records all auto- and cross-correlations generated by the x, y, and z
    dipolar components. To retain only the xx and xy correlations, one would set
    `matrix_elems=[(1,1), (1,2)]`.
- `process_trajectory`: Specify any preprocessing that should be applied to a
    recorded trajectory before calculating correlations. By default, no
    processing is applied. Options are `:symmetrize`, which symmetrizes the
    trajectory, and `:subtract_mean`, which subtracts the mean value. Both
    options are useful for eliminating Fourier artifacts that frequently appear
    when simulating gapless, or nearly gapless, Hamiltonians.

If you wish to calculate a dynamical structure factor, the keyword `nœâ` must set
to an integer greater than 1.
"""
function StructureFactor(sys::System; Œît = 0.1, nœâ = 1, œâmax = nothing,
                            apply_g = true, ops = nothing, matrix_elems = nothing,
                            process_trajectory = nothing)
    sftraj = SFTrajectory(sys; Œît, nœâ, œâmax, ops, apply_g, process_trajectory)
    sfdata = SFData(sys, sftraj; ops, matrix_elems)
    numsamps = 0

    return StructureFactor(sfdata, sftraj, numsamps)
end

# SFTrajectory is an internal type which specifies and stores a dynamical measurement,
# i.e., a trajectory. By default, SFTrajectory stores the x, y, and z dipolar components.
# In SU(_N_) mode, the user may optionally specify custom observables to record.
function SFTrajectory(sys::System{N}; 
    Œît = 0.1, nœâ = 1, œâmax = nothing, ops = nothing, apply_g = true,
    process_trajectory = nothing
) where N
    # Default to dipole expectation values if no observables have been given
    dipolemode = false 
    if isnothing(ops)
        dipolemode = true
        ops = zeros(ComplexF64, 0, 0, 3)  # ops are empty in this case
    else
        if N == 0 
            error("Structure Factor Error: Cannot provide matrices for observables when using dipolar `System`")
        end
    end

    # Determine meas_period (downsampling factor)
    if isnothing(œâmax) || nœâ == 1 # Default behavior and static SF mode
        measperiod = 1
    else
        @assert œÄ/Œît > œâmax "Maximum œâ with chosen step size is $(œÄ/Œît). Choose smaller Œît or change œâ_max."
        measperiod = floor(Int, œÄ/(Œît * œâmax))
    end

    # Determine any preprocessing of trajectory before FFT
    processtraj = if isnothing(process_trajectory)
        no_processing
    elseif process_trajectory == :symmetrize
        symmetrize!
    elseif process_trajectory == :subtract_mean
        subtract_mean!
    end

    # Preallocation
    nops = size(ops, 3)
    nœâ = nœâ == 1 ? 1 : 2nœâ-1 # nœâ = 1 is a static structure factor. If greater than 1, make nœâ correspond to the number of positive frequencies saved .
    traj = zeros(ComplexF64, nops, size(sys.dipoles)..., nœâ) 
    integrator = ImplicitMidpoint(Œît)

    # Create a shallow copy of the spin system
    sys_new = System(sys.mode, sys.crystal, sys.latsize, sys.interactions,
        copy(sys.dipoles), copy(sys.coherents), sys.Œ∫s, sys.gs,
        sys.dipole_buffers, sys.coherent_buffers, sys.units, sys.rng)

    return SFTrajectory(sys_new, traj, ops, measperiod, apply_g, dipolemode, integrator, processtraj)
end

function SFData(sys::System, sftraj::SFTrajectory; 
    ops = nothing, matrix_elems = nothing,
)
    nops =  isnothing(ops) ? 3 : size(ops, 3) # Assume three observables (spin operators) if none are explicitly given
    nœâ = size(sftraj.traj, 6)

    # Save all matrix elements if subset isn't given
    if isnothing(matrix_elems)
        matrix_elems = []
        for i in 1:nops, j in i:nops
            push!(matrix_elems, (i, j))
        end
    end

    # Construct look-up table for matrix elements
    count = 1
    pairs = []
    for elem in matrix_elems
        Œ±, Œ≤ = elem
        Œ±, Œ≤ = Œ± < Œ≤ ? (Œ±, Œ≤) : (Œ≤, Œ±)  # Because SF is symmetric, only save diagonal and upper triangular
        push!(pairs, (Œ±, Œ≤) => count)
        count += 1
    end
    pairs = map(i -> CartesianIndex(i.first) => i.second, pairs) # Convert to CartesianIndices
    idxinfo = SortedDict{CartesianIndex{2}, Int64}(pairs) # CartesianIndices sort to fastest order

    nb = nbasis(sys.crystal)
    data = zeros(ComplexF64, length(matrix_elems), nb, nb, sys.latsize..., nœâ)
    Œîœâ = 2œÄ / (sftraj.integrator.Œît*sftraj.measperiod*nœâ)

    return SFData{length(pairs)}(data, sys.crystal, Œîœâ, idxinfo)
end

"""
    calculate_structure_factor(sys::System, sampler::LangevinSampler; numsamps=10, kwargs...)

Calculates a `StructureFactor` containg ``ùíÆ(q,œâ)`` information with a single
function call. Must be given a [`System`](@ref) and a [`LangevinSampler`](@ref).
This functions expects that the spin state contained in the `System` to already
represent a good equilibrium sample. The function will use this state to
generate an initial trajectory. After generating this first trajectory, it will
call `sampler` before generating subsequent trajectories. In total, the function
will calculate `numsamps` trajectories and accumulate them into a
`StructureFactor` which is returned to the user. The remaining keyword arguments
are shared with [`StructureFactor`](@ref). 

Note that, to calculate a dynamic structure factor, the keyword `nœâ` must be set
to a integer greater than 1.
"""
function calculate_structure_factor(sys::System, sampler::AbstractSampler; 
                                        nsamples=10, Œît=nothing, nœâ=1, kwargs...)
    Œît = if isnothing(Œît) 
        if typeof(sampler) <: LangevinSampler
            2sampler.integrator.Œît
        else
            (nœâ != 1) && println("Warning: No integrator step size provided for structure factor dynamics. Using default.")
            0.1
        end
    end

    sf = StructureFactor(sys; Œît, nœâ, kwargs...)
    for _ in 1:nsamples
        sample!(sys, sampler)
        add_trajectory!(sf, sys)
    end

    return sf
end