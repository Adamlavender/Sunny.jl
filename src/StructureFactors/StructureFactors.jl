struct StructureFactor{N, NumCorr, NBasis}
    # 𝒮^{αβ}(q,ω) data and metadata
    data         :: Array{ComplexF64, 7}                  # Raw SF data for 1st BZ (numcorrelations x nbasis x nbasis x latsize x energy)
    crystal      :: Crystal                               # Crystal for interpretation of axes
    Δω           :: Float64                               # Energy step size

    # Correlation info (αβ indices of 𝒮^{αβ}(q,ω))
    dipoledata   :: Bool                                  # Whether correlations from dipoles 
    ops          :: Array{ComplexF64, 3}                  # Operators corresponding to observables
    idxinfo      :: SortedDict{CartesianIndex{2}, Int64}  # (α, β) to save from 𝒮^{αβ}(q, ω)

    # Specs for sample generation and accumulation
    samplebuf    :: Array{ComplexF64, 6}                  # New sample buffer
    measperiod   :: Int                                   # Steps to skip between saving observables (downsampling for dynamical calcs)
    apply_g      :: Bool                                  # Whether to apply the g-factor
    integrator   :: ImplicitMidpoint                      # Integrator for dissipationless trajectories (will likely move to add_sample!)
    nsamples     :: Array{Int64, 1}                       # Number of accumulated samples (array so mutable)
    processtraj! :: Function                              # Function to perform post-processing on sample trajectories
end

"""
    StructureFactor(sys::System; nω, Δt = 0.1, ωmax = nothing,
                        apply_g = true, ops = nothing, matrix_elems = nothing,
                        process_trajectory=:none)

`StructureFactor` is the basic type for calculating ``𝒮^{αβ}(q,ω)``, storing
the results, and retrieving intensity information. 

Most users should use [`calculate_structure_factor`](@ref) to generate a
structure factor. However, one may also directly create a structure factor by
providing a `System` to `StructureFactor`. Then, to manually generate a sample,
the user must ensure that the spins of their system are drawn from an
appropriate equilibrium distribution and call [`add_trajectory!`](@ref)
function. This process may be repeated as necessary to generate a sufficient
statistics. 

The keywords specify all the parameters used in subsequent calculations and must
be determined at the time that the `StructureFactor` is initiated. Specifically:
- `nω`: Required keyword argument that determines how many energy bins to
    resolve between 0 and `ωmax`. If set to 1, Sunny will calculate a static
    structure factor.
- `Δt`: Sets the step size of the integrator used to calculate trajectories.
- `ωmax`: Determines the maximum resolved energy.
- `apply_g`: Determines whether to apply the g-factor when calculating
    trajectories.
- `ops`: Enables an advanced feature for SU(_N_) mode, allowing the user to
    specify custom observables other than the three components of the dipole. To
    use this features, `ops` must be given an `N×N×numops` array, where the
    final index is used to retrieve each `N×N` operator.
- `matrix_elems`: Allows the user to specify which correlation functions are
    calculated. This is specified with a vector of tuples. By default Sunny
    records all auto- and cross-correlations generated by the x, y, and z
    dipolar components. To retain only the xx and xy correlations, one would set
    `matrix_elems=[(1,1), (1,2)]`.

If you wish to calculate a dynamical structure factor, the keyword `nω` must set
to an integer greater than 1.
"""
function StructureFactor(sys::System{N}; nω, Δt = 0.1, ωmax = nothing,
                            apply_g = true, ops = nothing, matrix_elems = nothing,
                            process_trajectory = :none) where N

    nω = Int64(nω)

    # Establish parameters for either static or dynamic sample generation
    if nω == 1  # Static structure factor
        measperiod = 1
        Δω = 0.0  
    else  # Dynamic structure factor 
        measperiod = if isnothing(ωmax) 
            1
        else
            @assert π/Δt > ωmax "Maximum ω with chosen step size is $(π/Δt). Choose smaller Δt or change ω_max."
            measperiod = floor(Int, π/(Δt * ωmax))
        end
        nω = 2nω-1 # Make nω correspond to number of non-negative frequencies
        Δω = 2π / (Δt*measperiod*nω)
    end

    # Set up correlation functions
    default_observables = false
    default_correlations = false
    if isnothing(ops)
        ops = zeros(ComplexF64, 0, 0, 3)  # ops are empty in this case
        default_observables = true
    else
        (N == 0) && error("Structure Factor Error: Cannot provide matrices for observables when using dipolar `System`")
    end
    nops = size(ops, 3)
    if isnothing(matrix_elems)
        matrix_elems = []
        for i in 1:nops, j in i:nops
            push!(matrix_elems, (i, j))
        end
        default_correlations = true
    end
    dipoledata = default_observables && default_correlations

    # Construct look-up table for matrix elements
    count = 1
    pairs = []
    for elem in matrix_elems
        α, β = elem
        α, β = α < β ? (α, β) : (β, α)  # Because SF is symmetric, only save diagonal and upper triangular
        push!(pairs, (α, β) => count)
        count += 1
    end
    pairs = map(i -> CartesianIndex(i.first) => i.second, pairs) # Convert to CartesianIndices
    idxinfo = SortedDict{CartesianIndex{2}, Int64}(pairs) # CartesianIndices sort to fastest order


    # Preallocation
    nb = nbasis(sys.crystal)
    ncorr = length(pairs)
    samplebuf = zeros(ComplexF64, nops, size(sys.dipoles)..., nω) 
    data = zeros(ComplexF64, length(matrix_elems), nb, nb, sys.latsize..., nω)
    nsamples = Int64[0]
    integrator = ImplicitMidpoint(Δt)


    # Set up trajectory processing function (e.g., symmetrize)
    processtraj! = if process_trajectory == :none 
        no_processing
    elseif process_trajectory == :symmetrize
        symmetrize!
    elseif process_trajectory == :subtractmean
        subtract_mean!
    else
        error("Unknown argument for `process_trajectory`")
    end


    # Make Structure factor and add an initial sample
    sf = StructureFactor{N, ncorr, nb}(data, sys.crystal, Δω, dipoledata, ops, idxinfo, samplebuf, 
                            measperiod, apply_g, integrator, nsamples, processtraj!)
    add_sample!(sf, sys; processtraj!)

    return sf
end

DynamicStructureFactor(sys::System; kwargs...) = StructureFactor(sys; kwargs...)
StaticStructureFactor(sys::System; kwargs...) = StructureFactor(sys; nω=1, kwargs...)